/**
 * Server-side authentication utility
 * Generates and verifies time-based HMAC signatures
 */

import crypto from 'crypto';

const SECRET_KEY = process.env.SECRET_KEY || '';
const TIMESTAMP_WINDOW_MS = 2 * 60 * 1000; // 2 minutes

/**
 * Generate HMAC signature for timestamp
 * SERVER-SIDE ONLY
 */
export function generateToken(): { token: string; timestamp: number } {
    const timestamp = Date.now();
    const token = crypto
        .createHmac('sha256', SECRET_KEY)
        .update(timestamp.toString())
        .digest('hex');

    return { token, timestamp };
}

/**
 * Verify token was generated by us and is within time window
 * SERVER-SIDE ONLY
 */
export function verifyToken(token: string, timestamp: number): boolean {
    if (!token || !timestamp || !SECRET_KEY) {
        return false;
    }

    try {
        // Check timestamp is within acceptable window (Â±2 minutes)
        // This tolerates network latency, computation time, and clock drift
        // Accepts timestamps that are up to 2 min in past OR future
        const now = Date.now();
        const timeDiff = Math.abs(now - timestamp);

        if (timeDiff > TIMESTAMP_WINDOW_MS) {
            console.warn(`Token expired: time diff ${Math.floor(timeDiff / 1000)}s (max 120s)`);
            return false;
        }

        // Verify token matches what we would generate for this timestamp
        const expectedToken = crypto
            .createHmac('sha256', SECRET_KEY)
            .update(timestamp.toString())
            .digest('hex');

        // Timing-safe comparison
        return crypto.timingSafeEqual(
            Buffer.from(token, 'hex'),
            Buffer.from(expectedToken, 'hex')
        );
    } catch (error) {
        console.error('Token verification error:', error);
        return false;
    }
}
